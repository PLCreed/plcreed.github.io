<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="第19章 特殊工具与技术, 七日卡农">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>第19章 特殊工具与技术 | 七日卡农</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="七日卡农" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">七日卡农</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">七日卡农</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/6.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">第19章 特殊工具与技术</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="container content">

    
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/C-Primer-5th/">
                                <span class="chip bg-color">C++ Primer 5th</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/C-Primer-5th/" class="post-category">
                                C++ Primer 5th
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-05-02
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-05-02
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    35 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="第19章-特殊工具与技术"><a href="#第19章-特殊工具与技术" class="headerlink" title="第19章 特殊工具与技术"></a>第19章 特殊工具与技术</h1><h2 id="控制内存分配（Controlling-Memory-Allocation）"><a href="#控制内存分配（Controlling-Memory-Allocation）" class="headerlink" title="控制内存分配（Controlling Memory Allocation）"></a>控制内存分配（Controlling Memory Allocation）</h2><h3 id="重载new和delete（Overloading-new-and-delete）"><a href="#重载new和delete（Overloading-new-and-delete）" class="headerlink" title="重载new和delete（Overloading new and delete）"></a>重载new和delete（Overloading new and delete）</h3><p>使用<code>new</code>表达式时，实际执行了三步操作：</p>
<ul>
<li><code>new</code>表达式调用名为<code>operator new</code>（或<code>operator new[]</code>）的标准库函数。该函数分配一块足够大、原始、未命名的内存空间以便存储特定类型的对象（或对象数组）。</li>
<li>编译器调用对应的构造函数构造这些对象并初始化。</li>
<li>对象被分配了空间并构造完成，返回指向该对象的指针。</li>
</ul>
<p>使用<code>delete</code>表达式时，实际执行了两步操作：</p>
<ul>
<li>对指针所指向的对象（或对象数组）执行对应的析构函数。</li>
<li>编译器调用名为<code>operator delete</code>（或<code>operator delete[]</code>）的标准库函数释放内存空间。</li>
</ul>
<p>如果程序希望控制内存分配的过程，则需要定义自己的<code>operator new</code>和<code>operator delete</code>函数。编译器会用自定义版本替换标准库版本。</p>
<p>程序可以在全局作用域中定义<code>operator new</code>和<code>operator delete</code>函数，也可以将其定义为成员函数。编译器发现<code>new</code>或<code>delete</code>表达式后，将在程序中查找可供调用的<code>operator</code>函数。如果被分配或释放的对象是类类型，编译器会先在类及其基类的作用域中查找。如果该类含有<code>operator</code>成员，则表达式会调用这些成员。否则编译器会继续在全局作用域查找。如果找到自定义版本，则使用该版本的函数。如果没找到，则使用标准库定义的版本。</p>
<p>可以使用作用域运算符令<code>new</code>或<code>delete</code>表达式忽略定义在类中的函数，直接执行全局作用域版本。</p>
<p>标准库定义了<code>operator new</code>和<code>operator delete</code>函数的8个重载版本，其中前4个版本可能抛出<code>bad_alloc</code>异常，后4个版本不会抛出异常。重载这些运算符时，必须使用关键字<code>noexcept</code>指定其不抛出异常。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; these versions might throw an exception
void *operator new(size_t);     &#x2F;&#x2F; allocate an object
void *operator new[](size_t);   &#x2F;&#x2F; allocate an array
void *operator delete(void*) noexcept;      &#x2F;&#x2F; free an object
void *operator delete[](void*) noexcept;    &#x2F;&#x2F; free an array
&#x2F;&#x2F; versions that promise not to throw
void *operator new(size_t, nothrow_t&amp;) noexcept;
void *operator new[](size_t, nothrow_t&amp;) noexcept;
void *operator delete(void*, nothrow_t&amp;) noexcept;
void *operator delete[](void*, nothrow_t&amp;) noexcept<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>nothrow_t</code>类型是定义在头文件<em>new</em>中的一个结构体，这个类型不包含任何成员。头文件<em>new</em>还定义了一个名为<code>nothrow</code>的<code>const</code>对象，用户可以通过这个对象请求<code>new</code>的非抛出版本。</p>
<p>将<code>operator</code>函数定义为类的成员时，它们是隐式静态的，无须显式地声明<code>static</code>。因为<code>operator new</code>用在对象构造之前，<code>operator delete</code>用在对象销毁之后，所以它们必须是静态成员，而且不能操纵类的任何数据成员。</p>
<p><code>operator new</code>和<code>operator new[]</code>函数的返回类型必须是<code>void*</code>，第一个形参的类型必须是<code>size_t</code>且不能有默认实参。编译器调用<code>operator new</code>时，用存储指定类型对象所需的字节数初始化<code>size_t</code>形参；调用<code>operator new[]</code>时，传入函数的则是存储数组中所有元素所需的空间。</p>
<p>自定义<code>operator new</code>函数时可以为它提供额外的形参，用到这些自定义函数的<code>new</code>表达式必须使用<code>new</code>的定位形式传递参数。下面这种形式的<code>new</code>函数只供标准库使用，不能被用户重定义：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void *operator new(size_t, void*);   &#x2F;&#x2F; this version may not be redefined<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>operator delete</code>和<code>operator delete[]</code>函数的返回类型必须是<code>void</code>，第一个形参的类型必须是<code>void*</code>。函数被调用时，编译器会用指向待释放内存的指针来初始化<code>void*</code>形参。</p>
<p>将<code>operator delete</code>或<code>operator delete[]</code>定义为类的成员时，可以包含另一个类型为<code>size_t</code>的形参。该形参的初始值是第一个形参所指向对象的字节数。<code>size_t</code>形参可用于删除继承体系中的对象。如果基类有一个虚析构函数，则传递给<code>operator delete</code>的字节数会因待删除指针所指向对象的动态类型不同而有所区别。实际运行的<code>operator delete</code>函数版本也由对象的动态类型决定。</p>
<p><code>malloc</code>函数接受一个表示待分配字节数的<code>size_t</code>参数，返回指向分配空间的指针，或者返回0以表示分配失败。<code>free</code>函数接受一个<code>void*</code>参数，它是<code>malloc</code>返回的指针的副本，<code>free</code>将相关内存返回给系统。调用<code>free(0)</code>没有任何意义。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void *operator new(size_t size)
&#123;
    if (void *mem &#x3D; malloc(size))
        return mem;
    else
        throw bad_alloc();
&#125;

void operator delete(void *mem) noexcept
&#123;
    free(mem);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="定位new表达式（Placement-new-Expressions）"><a href="#定位new表达式（Placement-new-Expressions）" class="headerlink" title="定位new表达式（Placement new Expressions）"></a>定位new表达式（Placement new Expressions）</h3><p>在C++的早期版本中，<code>allocator</code>类还不是标准库的一部分。如果程序想分开内存分配和初始化过程，需要直接调用<code>operator new</code>和<code>operator delete</code>函数。它们类似<code>allocator</code>类的<code>allocate</code>和<code>deallocate</code>成员，负责分配或释放内存空间，但不会构造或销毁对象。</p>
<p>不能使用<code>allocator</code>类的<code>construct</code>函数在<code>operator new</code>分配的内存空间中构造对象，而应该使用定位<code>new</code>表达式构造。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] &#123; braced initializer list &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中<em>place_address</em>是一个指针。<em>initializers</em>是一个以逗号分隔的初始值列表（可能为空），该列表用于构造新分配的对象。</p>
<p>当仅通过一个地址值调用定位<code>new</code>时，它会使用<code>operator new(size_t, void*)</code>函数（用户无法重载的版本）。该函数不分配任何内存，直接返回指针形参。然后由<code>new</code>表达式负责在指定的地址初始化对象。</p>
<p>传递给<code>construct</code>函数的指针必须指向同一个<code>allocator</code>对象分配的空间，但是传递给定位<code>new</code>的指针无须指向<code>operator new</code>分配的内存，甚至不需要指向动态内存。</p>
<p>调用析构函数会销毁对象，但不会释放内存。如果需要的话，可以重新使用该空间。</p>
<h2 id="运行时类型识别（Run-Time-Type-Identification）"><a href="#运行时类型识别（Run-Time-Type-Identification）" class="headerlink" title="运行时类型识别（Run-Time Type Identification）"></a>运行时类型识别（Run-Time Type Identification）</h2><p>运行时类型识别（RTTI）的功能由两个运算符实现：</p>
<ul>
<li><code>typeid</code>运算符，用于返回表达式的类型。</li>
<li><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用。</li>
</ul>
<p>RTTI运算符适用于以下情况：想通过基类对象的指针或引用执行某个派生类操作，并且该操作不是虚函数。</p>
<h3 id="dynamic-cast运算符（The-dynamic-cast-Operator）"><a href="#dynamic-cast运算符（The-dynamic-cast-Operator）" class="headerlink" title="dynamic_cast运算符（The dynamic_cast Operator）"></a>dynamic_cast运算符（The dynamic_cast Operator）</h3><p><code>dynamic_cast</code>运算符的形式如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">dynamic_cast&lt;type*&gt;(e)
dynamic_cast&lt;type&amp;&gt;(e)
dynamic_cast&lt;type&amp;&amp;&gt;(e)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>其中<em>type</em>是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，<em>e</em>必须是一个有效指针；在第二种形式中，<em>e</em>必须是一个左值；在第三种形式中，<em>e</em>不能是左值。在所有形式中，<em>e</em>的类型必须符合以下条件之一：</p>
<ul>
<li><em>e</em>是<em>type</em>的公有派生类。</li>
<li><em>e</em>是<em>type</em>的公有基类。</li>
<li><em>e</em>和<em>type</em>类型相同。</li>
</ul>
<p>如果条件符合，则类型转换成功，否则转换失败。转换失败可能有两种结果：</p>
<ul>
<li><p>如果<code>dynamic_cast</code>语句的转换目标是指针类型，则结果为0。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (Derived *dp &#x3D; dynamic_cast&lt;Derived*&gt;(bp))
&#123;
    &#x2F;&#x2F; use the Derived object to which dp points
&#125;
else
&#123;   &#x2F;&#x2F; bp points at a Base object
    &#x2F;&#x2F; use the Base object to which bp points
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>如果<code>dynamic_cast</code>语句的转换目标是引用类型，则抛出<code>bad_cast</code>异常（定义在头文件<em>typeinfo</em>中）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void f(const Base &amp;b)
&#123;
    try
    &#123;
        const Derived &amp;d &#x3D; dynamic_cast&lt;const Derived&amp;&gt;(b);
        &#x2F;&#x2F; use the Derived object to which b referred
    &#125;
    catch (bad_cast)
    &#123;
        &#x2F;&#x2F; handle the fact that the cast failed
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>在条件判断部分执行<code>dynamic_cast</code>可以确保类型转换和结果检查在同一条表达式中完成。</p>
<p>可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针。</p>
<h3 id="typeid运算符（The-typeid-Operator）"><a href="#typeid运算符（The-typeid-Operator）" class="headerlink" title="typeid运算符（The typeid Operator）"></a>typeid运算符（The typeid Operator）</h3><p><code>typeid</code>表达式的形式是<code>typeid(e)</code>，其中<em>e</em>可以是任意表达式或类型名称。<code>typeid</code>的结果是一个指向常量对象的引用，该对象的类型是标准库<code>type_info</code>（定义在头文件<em>typeinfo</em>中）或<code>type_info</code>的公有派生类型。</p>
<p><code>typeid</code>可以作用于任何类型的表达式，其中的顶层<code>const</code>会被忽略。如果表达式是一个引用，则<code>typeid</code>返回该引用所指对象的类型。当<code>typeid</code>作用于数组或函数时，不会执行向指针的标准类型转换。</p>
<p>当<code>typeid</code>的运算对象不属于类类型或者是一个不包含任何虚函数的类时，<code>typeid</code>返回其静态类型。而当运算对象是至少包含一个虚函数的类的左值时，<code>typeid</code>的结果直到运行期间才会确定。</p>
<p>通常情况下，<code>typeid</code>用于比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Derived *dp &#x3D; new Derived;
Base *bp &#x3D; dp;   &#x2F;&#x2F; both pointers point to a Derived object
&#x2F;&#x2F; compare the type of two objects at run time
if (typeid(*bp) &#x3D;&#x3D; typeid(*dp))
&#123;
    &#x2F;&#x2F; bp and dp point to objects of the same type
&#125;
&#x2F;&#x2F; test whether the run-time type is a specific type
if (typeid(*bp) &#x3D;&#x3D; typeid(Derived))
&#123;
    &#x2F;&#x2F; bp actually points to a Derived
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>typeid</code>应该作用于对象。当<code>typeid</code>作用于指针时，返回的结果是该指针的静态编译类型。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; test always fails: the type of bp is pointer to Base
if (typeid(bp) &#x3D;&#x3D; typeid(Derived))
&#123;
    &#x2F;&#x2F; code never executed
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>只有当类型含有虚函数时，编译器才会对<code>typeid</code>的表达式求值以确定返回类型。对于<code>typeid(*p)</code>，如果指针<em>p</em>所指向的类型不包含虚函数，则<em>p</em>可以是一个无效指针。否则<code>*p</code>会在运行期间求值，此时<em>p</em>必须是一个有效指针。如果<em>p</em>是空指针，<code>typeid(*p)</code>会抛出<code>bad_typeid</code>异常。</p>
<h3 id="使用RTTI（Using-RTTI）"><a href="#使用RTTI（Using-RTTI）" class="headerlink" title="使用RTTI（Using RTTI）"></a>使用RTTI（Using RTTI）</h3><p>使用RTTI可以为具有继承关系的类实现相等运算符。</p>
<p>相等运算符的形参是基类的引用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base
&#123;
    friend bool operator&#x3D;&#x3D;(const Base&amp;, const Base&amp;);
public:
    &#x2F;&#x2F; interface members for Base
protected:
    virtual bool equal(const Base&amp;) const;
    &#x2F;&#x2F; data and other implementation members of Base
&#125;;

class Derived: public Base
&#123;
public:
    &#x2F;&#x2F; other interface members for Derived
protected:
    bool equal(const Base&amp;) const;
    &#x2F;&#x2F; data and other implementation members of Derived
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用<code>typeid</code>检查两个运算对象的类型是否一致，类型一致才会继续判断每个数据成员的取值是否相同。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool operator&#x3D;&#x3D;(const Base &amp;lhs, const Base &amp;rhs)
&#123;
    &#x2F;&#x2F; returns false if typeids are different; otherwise makes a virtual call to equal
    return typeid(lhs) &#x3D;&#x3D; typeid(rhs) &amp;&amp; lhs.equal(rhs);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每个类定义的<code>equal</code>函数负责比较类型自己的数据成员。<code>equal</code>函数的形参都是基类的引用，但是在比较之前需要先把运算对象转换成自己的类型。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool Derived::equal(const Base &amp;rhs) const
&#123;
    &#x2F;&#x2F; we know the types are equal, so the cast won&#39;t throw
    auto r &#x3D; dynamic_cast&lt;const Derived&amp;&gt;(rhs);
    &#x2F;&#x2F; do the work to compare two Derived objects and return the result
&#125;

bool Base::equal(const Base &amp;rhs) const
&#123;
&#x2F;&#x2F; do whatever is required to compare to Base objects
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="type-info类（The-type-info-Class）"><a href="#type-info类（The-type-info-Class）" class="headerlink" title="type_info类（The type_info Class）"></a>type_info类（The type_info Class）</h3><p><code>type_info</code>类的精确定义会根据编译器的不同而略有差异。但是C++规定<code>type_info</code>必须定义在头文件<em>typeinfo</em>中，并且至少提供以下操作：</p>
<p><img src="/2021/05/02/cpp-primer-5th-notes/di-19-zhang-te-shu-gong-ju-yu-ji-zhu/readme/19-1.png" alt="19-1"></p>
<p><code>type_info</code>类一般是作为一个基类出现，所以它还应该提供一个公有虚析构函数。当编译器希望提供额外的类型信息时，通常在<code>type_info</code>的派生类中完成。</p>
<p><code>type_info</code>类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义为删除的。创建<code>type_info</code>对象的唯一方式就是使用<code>typeid</code>运算符。</p>
<p>对于某种给定类型来说，<code>name</code>成员的返回值因编译器而异并且不一定与在程序中使用的名字一致。对于<code>name</code>返回值的唯一要求就是类型不同则返回的字符串必须有所区别。</p>
<h2 id="枚举类型（Enumerations）"><a href="#枚举类型（Enumerations）" class="headerlink" title="枚举类型（Enumerations）"></a>枚举类型（Enumerations）</h2><p>和类一样，每个枚举类型都定义了一种新的类型。枚举属于字面值常量类型。</p>
<p>C++包含两种枚举：</p>
<ul>
<li><p>限定作用域的枚举（scoped enumeration，C++11新增）。定义形式是关键字<code>enum class</code>（或<code>enum struct</code>）后接枚举类型名字以及用花括号包围、以逗号分隔的枚举成员（enumerator）列表。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum class open_modes
&#123;
    input,
    output,
    append
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>不限定作用域的枚举（unscoped enumeration）。定义时省略关键字<code>class</code>（或<code>struct</code>），枚举类型名字是可选的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">C++&#x2F;&#x2F; unscoped enumeration
enum color
&#123;
    red,
    yellow,
    green
&#125;;
&#x2F;&#x2F; unnamed, unscoped enum
enum
&#123;
    floatPrec &#x3D; 6,
    doublePrec &#x3D; 10,
    double_doublePrec &#x3D; 10
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果枚举是未命名的，则只能在定义该枚举时一同定义它的对象。</p>
</li>
</ul>
<p>在限定作用域的枚举类型中，枚举成员的名字遵循常规作用域规则，并且在枚举类型的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum color &#123; red, yellow, green &#125;;   &#x2F;&#x2F; unscoped enumeration
enum stoplight &#123; red, yellow, green &#125;;   &#x2F;&#x2F; error: redefines enumerators
enum class peppers &#123; red, yellow, green &#125;;   &#x2F;&#x2F; ok: enumerators are hidden
color eyes &#x3D; green;    &#x2F;&#x2F; ok: enumerators are in scope for an unscoped enumeration
peppers p &#x3D; green;     &#x2F;&#x2F; error: enumerators from peppers are not in scope
&#x2F;&#x2F; color::green is in scope but has the wrong type
color hair &#x3D; color::red;      &#x2F;&#x2F; ok: we can explicitly access the enumerators
peppers p2 &#x3D; peppers::red;    &#x2F;&#x2F; ok: using red from peppers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>默认情况下，枚举值从0开始，依次加1。也可以直接为枚举成员指定特定的值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum class intTypes
&#123;
    charTyp &#x3D; 8, shortTyp &#x3D; 16, intTyp &#x3D; 16,
    longTyp &#x3D; 32, long_longTyp &#x3D; 64
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>枚举值可以不唯一。如果没有显式提供初始值，则当前枚举成员的值等于之前枚举成员的值加1。</p>
<p>枚举成员是<code>const</code>的，因此在初始化枚举成员时提供的初始值必须是常量表达式。</p>
<p>可以在任何需要常量表达式的地方使用枚举成员。如：</p>
<ul>
<li>定义枚举类型的<code>constexpr</code>变量。</li>
<li>将枚举类型对象作为<code>switch</code>语句的表达式，而将枚举值作为<code>case</code>标签。</li>
<li>将枚举类型作为非类型模板形参使用。</li>
<li>在类的定义中初始化枚举类型的静态数据成员。</li>
</ul>
<p>初始化枚举对象或者给枚举对象赋值时，必须使用该类型的一个枚举成员或者该类型的另一个对象。即使某个整型值恰好与枚举成员的值相等，也不能用其初始化枚举对象。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">open_modes om &#x3D; 2;        &#x2F;&#x2F; error: 2 is not of type open_modes
om &#x3D; open_modes::input;   &#x2F;&#x2F; ok: input is an enumerator of open_modes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>不限定作用域的枚举类型对象或枚举成员能自动转换成整型。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i &#x3D; color::red;     &#x2F;&#x2F; ok: unscoped enumerator implicitly converted to int
int j &#x3D; peppers::red;   &#x2F;&#x2F; error: scoped enumerations are not implicitly converted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>枚举是由某种整数类型表示的。C++11中，可以在枚举名字后面指定用来表示枚举成员的整型类型。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum intValues : unsigned long long
&#123;
    &#x2F;*...*&#x2F;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果没有指定枚举的潜在类型，则默认情况下限定作用域的枚举成员类型是<code>int</code>。不限定作用域的枚举成员不存在默认类型。</p>
<p>C++11中可以提前声明枚举。枚举的前置声明必须指定（无论隐式或显式）其成员的类型。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; forward declaration of unscoped enum named intValues
enum intValues : unsigned long long;    &#x2F;&#x2F; unscoped, must specify a type
enum class open_modes;    &#x2F;&#x2F; scoped enums can use int by default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="类成员指针（Pointer-to-Class-Member）"><a href="#类成员指针（Pointer-to-Class-Member）" class="headerlink" title="类成员指针（Pointer to Class Member）"></a>类成员指针（Pointer to Class Member）</h2><p>成员指针（pointer to member）是指可以指向类的非静态成员的指针。</p>
<p>成员指针的类型包括类的类型和成员的类型。初始化成员指针时，会令其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。</p>
<h3 id="数据成员指针（Pointers-to-Data-Members）"><a href="#数据成员指针（Pointers-to-Data-Members）" class="headerlink" title="数据成员指针（Pointers to Data Members）"></a>数据成员指针（Pointers to Data Members）</h3><p>声明成员指针时必须在<code>*</code>前添加<code>classname::</code>以表示当前定义的指针可以指向<em>classname</em>的成员。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Screen
&#123;
public:
    typedef std::string::size_type pos;
    char get_cursor() const &#123; return contents[cursor]; &#125;
    char get() const;
    char get(pos ht, pos wd) const;

private:
    std::string contents;
    pos cursor;
    pos height, width;
&#125;

&#x2F;&#x2F; pdata can point to a string member of a const (or non const) Screen object
const string Screen::*pdata;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>初始化或者给成员指针赋值时，需要指定它所指向的成员。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pdata &#x3D; &amp;Screen::contents;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>成员指针使用<code>.*</code>和<code>-&gt;*</code>来获得其指向对象的成员。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Screen myScreen, *pScreen &#x3D; &amp;myScreen;
&#x2F;&#x2F; .* dereferences pdata to fetch the contents member from the object myScreen
auto s &#x3D; myScreen.*pdata;
&#x2F;&#x2F; -&gt;* dereferences pdata to fetch contents from the object to which pScreen points
s &#x3D; pScreen-&gt;*pdata;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>常规的访问控制规则对成员指针同样有效。数据成员一般是私有的，因此通常不能直接获得数据成员的指针。如果类希望外部代码能访问它的私有数据成员，可以定义一个函数，令其返回指向私有成员的指针。</p>
<h3 id="成员函数指针（Pointers-to-Member-Functions）"><a href="#成员函数指针（Pointers-to-Member-Functions）" class="headerlink" title="成员函数指针（Pointers to Member Functions）"></a>成员函数指针（Pointers to Member Functions）</h3><p>类似于其他函数指针，指向成员函数的指针也需要指定目标函数的返回类型和形参列表。如果成员函数是<code>const</code>成员或引用成员，则指针也必须包含<code>const</code>或引用限定符。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; pmf is a pointer that can point to a Screen member function that is const
&#x2F;&#x2F; that returns a char and takes no arguments
auto pmf &#x3D; &amp;Screen::get_cursor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果成员函数存在重载问题，则必须显式声明指针指向的函数类型。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char (Screen::*pmf2)(Screen::pos, Screen::pos) const;
pmf2 &#x3D; &amp;Screen::get;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>和普通函数指针不同，在成员函数和指向该成员的指针之间不存在自动转换规则。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; pmf points to a Screen member that takes no arguments and returns char
pmf &#x3D; &amp;Screen::get;    &#x2F;&#x2F; must explicitly use the address-of operator
pmf &#x3D; Screen::get;     &#x2F;&#x2F; error: no conversion to pointer for member functions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>成员函数指针使用<code>.*</code>和<code>-&gt;*</code>来调用类的成员函数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Screen myScreen, *pScreen &#x3D; &amp;myScreen;
&#x2F;&#x2F; call the function to which pmf points on the object to which pScreen points
char c1 &#x3D; (pScreen-&gt;*pmf)();
&#x2F;&#x2F; passes the arguments 0, 0 to the two-parameter version of get on the object myScreen
char c2 &#x3D; (myScreen.*pmf2)(0, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以使用类型别名来增强含有成员指针的代码的可读性。</p>
<h3 id="将成员函数用作可调用对象（Using-Member-Functions-as-Callable-Objects）"><a href="#将成员函数用作可调用对象（Using-Member-Functions-as-Callable-Objects）" class="headerlink" title="将成员函数用作可调用对象（Using Member Functions as Callable Objects）"></a>将成员函数用作可调用对象（Using Member Functions as Callable Objects）</h3><p>成员指针不是一个可调用对象，不支持函数调用运算符。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto fp &#x3D; &amp;string::empty;   &#x2F;&#x2F; fp points to the string empty function
&#x2F;&#x2F; error: must use .* or -&gt;* to call a pointer to member
find_if(svec.begin(), svec.end(), fp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>从成员函数指针获取可调用对象的一种方法是使用标准库模板<code>function</code>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">function&lt;bool (const string&amp;)&gt; fcn &#x3D; &amp;string::empty;
find_if(svec.begin(), svec.end(), fcn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>定义一个<code>function</code>对象时，必须指定该对象所能表示的函数类型（即可调用对象的形式）。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个对象上执行的。</p>
<p>使用标准库功能<code>mem_fn</code>（定义在头文件<em>functional</em>中）可以让编译器推断成员的类型。和<code>function</code>一样，<code>mem_fn</code>可以从成员指针生成可调用对象。但<code>mem_fn</code>可以根据成员指针的类型推断可调用对象的类型，无须显式指定。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">find_if(svec.begin(), svec.end(), mem_fn(&amp;string::empty));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>mem_fn</code>生成的可调用对象可以通过对象和指针调用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto f &#x3D; mem_fn(&amp;string::empty);    &#x2F;&#x2F; f takes a string or a string*
f(*svec.begin());   &#x2F;&#x2F; ok: passes a string object; f uses .* to call empty
f(&amp;svec[0]);        &#x2F;&#x2F; ok: passes a pointer to string; f uses .-&gt; to call empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="嵌套类（Nested-Classes）"><a href="#嵌套类（Nested-Classes）" class="headerlink" title="嵌套类（Nested Classes）"></a>嵌套类（Nested Classes）</h2><p>一个类可以定义在另一个类的内部，前者被称为嵌套类或嵌套类型（nested type）。嵌套类通常用于定义作为实现部分的类。</p>
<p>外层类的对象和嵌套类的对象是相互独立的。在嵌套类对象中不包含任何外层类定义的成员，在外层类对象中也不包含任何嵌套类定义的成员。</p>
<p>嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。</p>
<p>外层类对嵌套类的成员没有特殊的访问权限，嵌套类对外层类的成员也没有特殊的访问权限。</p>
<p>嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类的访问说明符决定。</p>
<p>嵌套类必须声明在类的内部，但是可以定义在类的内部或外部。在外层类之外定义嵌套类时，必须用外层类的名字限定嵌套类的名字。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class TextQuery
&#123;
    class QueryResult;  &#x2F;&#x2F; nested class to be defined later
&#125;;

&#x2F;&#x2F; we&#39;re defining the QueryResult class that is a member of class TextQuery
class TextQuery::QueryResult
&#123;
    &#x2F;*...*&#x2F;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型。</p>
<h2 id="union：一种节省空间的类（union-A-Space-Saving-Class）"><a href="#union：一种节省空间的类（union-A-Space-Saving-Class）" class="headerlink" title="union：一种节省空间的类（union: A Space-Saving Class）"></a>union：一种节省空间的类（union: A Space-Saving Class）</h2><p>联合（union）是一种特殊的类。一个联合可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。给联合的某个成员赋值之后，其他成员会变为未定义状态。分配给联合对象的存储空间至少要能容纳它的最大数据成员。</p>
<p>联合不能包含引用类型的成员。在C++11中，含有构造函数或析构函数的类类型也可以作为联合的成员类型。</p>
<p>联合可以为其成员指定<code>public</code>、<code>protected</code>和<code>private</code>等保护标记。默认情况下，联合的成员都是公有的。</p>
<p>联合可以定义包括构造函数和析构函数在内的成员函数。但是由于联合既不能继承自其他类，也不能作为基类使用，所以在联合中不能含有虚函数。</p>
<p>定义联合时，首先是关键字<code>union</code>，随后是该联合的名字（可选）以及在花括号内的一组成员声明。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; objects of type Token have a single member, which could be of any of the listed types
union Token
&#123;
    &#x2F;&#x2F; members are public by default
    char cval;
    int ival;
    double dval;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>默认情况下，联合是未初始化的。可以像显式初始化聚合类一样显式初始化联合，提供的初始值会被用于初始化第一个成员。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Token first_token &#x3D; &#123; &#39;a&#39; &#125;;   &#x2F;&#x2F; initializes the cval member<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以使用通用的成员访问运算符访问联合对象的成员。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">last_token.cval &#x3D; &#39;z&#39;;
pt-&gt;ival &#x3D; 42;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>匿名联合（anonymous union）是一个未命名的联合，并且在右花括号和分号之间没有任何声明。一旦定义了一个匿名联合，编译器就会自动地为该联合创建一个未命名的对象。在匿名联合的定义所在的作用域内，该联合的成员都是可以直接访问的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">union
&#123;   &#x2F;&#x2F; anonymous union
    char cval;
    int ival;
    double dval;
&#125;;  &#x2F;&#x2F; defines an unnamed object, whose members we can access directly

cval &#x3D; &#39;c&#39;;   &#x2F;&#x2F; assigns a new value to the unnamed, anonymous union object
ival &#x3D; 42;    &#x2F;&#x2F; that object now holds the value 42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>匿名联合不能包含<code>protected</code>和<code>private</code>成员，也不能定义成员函数。</p>
<p>C++的早期版本规定，在联合中不能含有定义了构造函数或拷贝控制成员的类类型成员。C++11取消了该限制。但是如果联合的成员类型定义了自己的构造函数或拷贝控制成员，该联合的用法会比只含有内置类型成员的联合复杂得多。</p>
<ul>
<li>当联合只包含内置类型的成员时，可以使用普通的赋值语句改变联合的值。但是如果想将联合的值改为类类型成员对应的值，或者将类类型成员的值改为一个其他值，则必须构造或析构该类类型的成员。</li>
<li>当联合只包含内置类型的成员时，编译器会按照成员顺序依次合成默认构造函数或拷贝控制成员。但是如果联合含有类类型成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器会为该联合合成对应的版本并将其声明为删除的。</li>
</ul>
<p>对于联合来说，构造或销毁类类型成员的操作非常复杂。通常情况下，可以把含有类类型成员的联合内嵌在另一个类中，这个类可以管理并控制与联合的类类型成员相关的状态转换。</p>
<h2 id="局部类（Local-Classes）"><a href="#局部类（Local-Classes）" class="headerlink" title="局部类（Local Classes）"></a>局部类（Local Classes）</h2><p>类可以定义在某个函数的内部，这种类被称为局部类。局部类定义的类型只能在定义它的作用域内可见。</p>
<p>局部类的所有成员（包括成员函数）都必须完整定义在类的内部，因此局部类的作用与嵌套类相比相差很远。</p>
<p>局部类中不允许声明静态数据成员。</p>
<p>局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员，不能使用普通局部变量。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a, val;
void foo(int val)
&#123;
    static int si;
    enum Loc &#123; a &#x3D; 1024, b &#125;;
    &#x2F;&#x2F; Bar is local to foo
    struct Bar
    &#123;
        Loc locVal;    &#x2F;&#x2F; ok: uses a local type name
        int barVal;
        void fooBar(Loc l &#x3D; a)  &#x2F;&#x2F; ok: default argument is Loc::a
        &#123;
            barVal &#x3D; val;    &#x2F;&#x2F; error: val is local to foo
            barVal &#x3D; ::val;  &#x2F;&#x2F; ok: uses a global object
            barVal &#x3D; si;     &#x2F;&#x2F; ok: uses a static local object
            locVal &#x3D; b;      &#x2F;&#x2F; ok: uses an enumerator
        &#125;
    &#125;;
    &#x2F;&#x2F; . . .
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>常规的访问保护规则对于局部类同样适用。外层函数对局部类的私有成员没有任何访问特权。局部类可以将外层函数声明为友元。</p>
<p>可以在局部类的内部再嵌套一个类。此时嵌套类的定义可以出现在局部类之外，不过嵌套类必须定义在与局部类相同的作用域中。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void foo()
&#123;
    class Bar
    &#123;
    public:
        class Nested;   &#x2F;&#x2F; declares class Nested
    &#125;;

    &#x2F;&#x2F; definition of Nested
    class Bar::Nested
    &#123;
    &#125;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。</p>
<h2 id="固有的不可移植的特性（Inherently-Nonportable-Features）"><a href="#固有的不可移植的特性（Inherently-Nonportable-Features）" class="headerlink" title="固有的不可移植的特性（Inherently Nonportable Features）"></a>固有的不可移植的特性（Inherently Nonportable Features）</h2><h3 id="位域（Bit-fields）"><a href="#位域（Bit-fields）" class="headerlink" title="位域（Bit-fields）"></a>位域（Bit-fields）</h3><p>类可以将其非静态数据成员定义成位域，在一个位域中含有一定数量的二进制位。当程序需要向其他程序或硬件设备传递二进制数据时，通常会使用位域。</p>
<p>位域的声明形式是在成员名字之后紧跟一个冒号和一个常量表达式，该表达式用于指定成员所占的二进制位数。</p>
<p>位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，所以通常情况下使用无符号类型保存位域。位域类型的大小不能小于位域结构的总大小。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Descriptor
&#123;
    &#x2F;&#x2F; error: should use unsigned long long
    unsigned int LimitLow : 16;
    unsigned int BaseLow : 24;
    unsigned int Attribute : 16;
    unsigned int BaseHigh : 8;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>定义位域时建议结合<code>#pragma pack</code>指令将结构体对齐值修改为1，防止数据结构错位。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 保存原始对齐值，设置新对齐
#pragma pack(push, 1)
&#x2F;&#x2F; 结构体定义……
&#x2F;&#x2F; 恢复原始对齐值
#pragma pack(pop)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>位域成员按定义顺序在内存中由低地址向高地址排列，具体布局与机器相关。</p>
<p>取地址符<code>&amp;</code>不能作用于位域，因此任何指针都无法指向类的位域。</p>
<p>如果可能的话，类内部连续定义的位域会压缩在同一整数的相邻位，从而提供存储压缩。</p>
<p>访问位域的方式与访问类的其他数据成员的方式类似。操作超过1位的位域时，通常会使用内置的位运算符。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">File &amp;File::open(File::modes m)
&#123;
    mode |&#x3D; READ;   &#x2F;&#x2F; set the READ bit by default
    &#x2F;&#x2F; other processing
    if (m &amp; WRITE)  &#x2F;&#x2F; if opening READ and WRITE
        &#x2F;&#x2F; processing to open the file in read&#x2F;write mode
        return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="volatile限定符（volatile-Qualifier）"><a href="#volatile限定符（volatile-Qualifier）" class="headerlink" title="volatile限定符（volatile Qualifier）"></a>volatile限定符（volatile Qualifier）</h3><p>当对象的值可能在程序的控制或检测之外被改变时（如子线程），应该将该对象声明为<code>volatile</code>。关键字<code>volatile</code>的作用是告知编译器不要优化这样的对象。</p>
<p><code>volatile</code>的确切含义与机器有关，只能通过查阅编译器文档来理解。要想让一个使用了<code>volatile</code>的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行一些修改。</p>
<p><code>volatile</code>的用法和<code>const</code>类似，都是对类型的额外修饰。二者相互之间并没有影响。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">volatile int display_register;   &#x2F;&#x2F; int value that might change
volatile Task *curr_task;        &#x2F;&#x2F; curr_task points to a volatile object
volatile int iax[max_size];      &#x2F;&#x2F; each element in iax is volatile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>类可以将成员函数定义为<code>volatile</code>的。<code>volatile</code>对象只能调用<code>volatile</code>成员函数。</p>
<p><code>volatile</code>和指针的关系类似<code>const</code>。可以声明<code>volatile</code>指针、指向<code>volatile</code>对象的指针和指向<code>volatile</code>对象的<code>volatile</code>指针。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">volatile int v;      &#x2F;&#x2F; v is a volatile int
int *volatile vip;   &#x2F;&#x2F; vip is a volatile pointer to int
volatile int *ivp;   &#x2F;&#x2F; ivp is a pointer to volatile int

&#x2F;&#x2F; vivp is a volatile pointer to volatile int
volatile int *volatile vivp;
int *ip &#x3D; &amp;v;   &#x2F;&#x2F; error: must use a pointer to volatile
*ivp &#x3D; &amp;v;      &#x2F;&#x2F; ok: ivp is a pointer to volatile
vivp &#x3D; &amp;v;      &#x2F;&#x2F; ok: vivp is a volatile pointer to volatile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不能使用合成的拷贝/移动构造函数和赋值运算符初始化<code>volatile</code>对象或者给<code>volatile</code>对象赋值。合成的成员接受的形参类型是非<code>volatile</code>常量引用，不能把非<code>volatile</code>引用绑定到<code>volatile</code>对象上。</p>
<p>如果类需要拷贝、移动或赋值它的<code>volatile</code>对象，则必须自定义拷贝或移动操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Foo
&#123;
public:
    Foo(const volatile Foo&amp;); &#x2F;&#x2F; copy from a volatile object
    &#x2F;&#x2F; assign from a volatile object to a nonvolatile object
    Foo&amp; operator&#x3D;(volatile const Foo&amp;);
    &#x2F;&#x2F; assign from a volatile object to a volatile object
    Foo&amp; operator&#x3D;(volatile const Foo&amp;) volatile;
    &#x2F;&#x2F; remainder of class Foo
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="链接指示：extern-“C”（Linkage-Directives：extern-“C”）"><a href="#链接指示：extern-“C”（Linkage-Directives：extern-“C”）" class="headerlink" title="链接指示：extern “C”（Linkage Directives：extern “C”）"></a>链接指示：extern “C”（Linkage Directives：extern “C”）</h3><p>C++程序有时需要调用使用其他语言编写的函数，最常见的是调用C语言函数。其他语言中的函数名字也必须在C++中进行声明。对于这些函数，编译器检查其调用的方式与处理普通C++函数的方式相同，但是生成的代码有所区别。C++使用链接指示指出任意非C++函数所用的语言。</p>
<p>链接指示有单个形式和复合形式，其不能出现在类定义或函数定义的内部。同样的链接指示必须出现在函数的每个声明处。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; illustrative linkage directives that might appear in the C++ header &lt;cstring&gt;
&#x2F;&#x2F; single-statement linkage directive
extern &quot;C&quot; size_t strlen(const char *);
&#x2F;&#x2F; compound-statement linkage directive
extern &quot;C&quot;
&#123;
    int strcmp(const char*, const char*);
    char *strcat(char*, const char*);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>链接指示包含关键字<code>extern</code>、字符串字面值常量和一个函数声明。其中的字符串字面值常量指出了编写函数所用的语言。</p>
<p>复合形式的链接指示可以应用于整个头文件。当一个<code>#include</code>指示被放置在复合链接指示的花括号中时，头文件中的所有函数声明都会被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含自带链接指示的函数，该函数不会受到影响。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; compound-statement linkage directive
extern &quot;C&quot;
&#123;
    #include &lt;string.h&gt;   &#x2F;&#x2F; C functions that manipulate C-style strings
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>C++从C语言继承的标准库函数可以定义成C函数，但并非必须。选择使用C还是C++实现C标准库，是由每个C++实现决定的。</p>
<p>编写函数所使用的语言是函数类型的一部分。因此对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示，而且指向这类函数的指针也必须使用与函数本身一样的链接指示。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; pf points to a C function that returns void and takes an int
extern &quot;C&quot; void (*pf)(int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>指向C函数的指针与指向C++函数的指针是不同的类型，两者不能相互赋值或初始化（少数C++编译器支持这种赋值操作并将其视为对语言的扩展，但是从严格意义上来说它是非法的）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void (*pf1)(int);   &#x2F;&#x2F; points to a C++ function
extern &quot;C&quot; void (*pf2)(int);    &#x2F;&#x2F; points to a C function
pf1 &#x3D; pf2;   &#x2F;&#x2F; error: pf1 and pf2 have different types<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>链接指示不仅对函数本身有效，对作为返回类型或形参类型的函数指针也有效。所以如果希望给C++函数传入指向C函数的指针，必须使用类型别名。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; f1 is a C function; its parameter is a pointer to a C function
extern &quot;C&quot; void f1(void(*)(int));
&#x2F;&#x2F; FC is a pointer to a C function
extern &quot;C&quot; typedef void FC(int);
&#x2F;&#x2F; f2 is a C++ function with a parameter that is a pointer to a C function
void f2(FC *);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过链接指示定义函数，可以令C++函数在其他语言编写的程序中可用。编译器会为该函数生成适合于指定语言的代码。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; the calc function can be called from C programs
extern &quot;C&quot; double calc(double dparm) &#123; &#x2F;* ... *&#x2F; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果需要在C和C++中编译同一个源文件，可以在编译C++版本时使用预处理定义<code>__cplusplus</code>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"># ifdef __cplusplus
&#x2F;&#x2F; ok: we&#39;re compiling C++
extern &quot;C&quot;
# endif
int strcmp(const char*, const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>链接指示与重载函数的相互作用依赖于目标语言。C语言不支持函数重载，所以一个C链接指示只能用于说明一组重载函数中的某一个。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; error: two extern &quot;C&quot; functions with the same name
extern &quot;C&quot; void print(const char*);
extern &quot;C&quot; void print(int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">七日卡农</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.plcreed.com/2021/05/02/cpp-primer-5th-notes/di-19-zhang-te-shu-gong-ju-yu-ji-zhu/readme/">https://www.plcreed.com/2021/05/02/cpp-primer-5th-notes/di-19-zhang-te-shu-gong-ju-yu-ji-zhu/readme/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">七日卡农</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/C-Primer-5th/">
                                    <span class="chip bg-color">C++ Primer 5th</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2021/05/02/cpp-primer-5th-notes/di-19-zhang-te-shu-gong-ju-yu-ji-zhu/readme/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="第19章 特殊工具与技术">
                        
                        <span class="card-title">第19章 特殊工具与技术</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-05-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C-Primer-5th/" class="post-category">
                                    C++ Primer 5th
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C-Primer-5th/">
                        <span class="chip bg-color">C++ Primer 5th</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/05/02/cpp-primer-5th-notes/di-18-zhang-yong-yu-da-xing-cheng-xu-de-gong-ju/readme/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="第18章 用于大型程序的工具">
                        
                        <span class="card-title">第18章 用于大型程序的工具</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-05-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C-Primer-5th/" class="post-category">
                                    C++ Primer 5th
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C-Primer-5th/">
                        <span class="chip bg-color">C++ Primer 5th</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="711320481"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">七日卡农</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">106.1k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/PLCreed" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:731174410@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=488955394" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 488955394" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
